{
    "collab_server" : "",
    "contents" : "## ------------------------------------------------------------------------- ##\nsplitdir <- function(x, spx, parter = NULL)\n{\n  mycut <- split(x, wdpart(spx, parter = parter))\n  mycut[[1]] <- rbind(mycut[[1]], mycut[[length(mycut)]])\n  mycut <- mycut[1:(length(mycut)-1)]\n  names(mycut) <- getdirections(parter)\n  mycut\n}\n\n## ------------------------------------------------------------------------- ##\nwdpart <- function(x, parter = NULL, north = NULL)\n{\n  wdir <- getdirections(parter = parter)\n  nparter <- length(wdir)\n  if (any(x == 0)) x[x == 0] <- 360\n  br <- c(0, (1:nparter) * 360/nparter - 360/nparter/2, 360)\n  cut(x, breaks = br)#, labels = c(wdir, wdir[1]))\n}\n\n## ------------------------------------------------------------------------- ##\ngetdirections <- function(parter = NULL, newdir = NULL)\n{ #, north = NULL\n  require(addfuns)\n  basedir <- c(\"N\",\"E\",\"S\",\"W\")\n  if (is.null(parter)) parter <- 4\n  if (is.null(newdir)) newdir <- basedir\n  stopifnot(parter %% 4 == 0)\n  \n  if (length(newdir) >= parter) {\n    return(newdir)\n  } else {\n    newdir0 <- newdir\n    n0 <- odd(newdir0)\n    (addir <- paste0(c(n0[1], rep(n0[-1], each = 2), n0[1]), rep(even(newdir0), each = 2)))\n    newdir <- vector(\"character\", length = length(newdir0) + length(addir))\n    newdir[1:length(newdir) %% 2 == 1] <- newdir0\n    newdir[1:length(newdir) %% 2 == 0] <- addir\n    getdirections(parter = parter, newdir = newdir)\n  }\n}\n\n## ------------------------------------------------------------------------- ##\nassign_wd <- function(x, type = NULL) {\n  if (is.na(x)) {\n    return(NA)\n  } else {\n    stopifnot(is.numeric(x) & x >= 0 & x <= 360)\n    if (is.null(type)) type = \"char\"\n    if (type == \"char\") {\n      if (x < 45 | x >= 315) return(\"N\")\n      else if (x >= 45 & x < 135) return(\"E\")\n      else if (x >= 135 & x < 225) return(\"S\")\n      else if (x >= 225 & x < 315) return(\"W\")\n      else stop(\"No solution!\")\n    } else if (type == \"num\") {\n      if (x < 45 | x >= 315) return(1)\n      else if (x >= 45 & x < 135) return(2)\n      else if (x >= 135 & x < 225) return(3)\n      else if (x >= 225 & x < 315) return(4)\n      else stop(\"No solution!\")\n    } else stop(\"Input \\\"x\\\" has to be either of type \\\"char\\\" or \\\"num\\\"!\")\n  }\n}\n\nassign_ws <- function(x, type = NULL) {\n  if (is.na(x)) {\n    return(NA)\n  } else {\n    stopifnot(is.numeric(x) & x >= 0)\n    if(is.null(type)) type = \"char\"\n    if(type == \"char\") {\n      if (x < 10) return(\"L\")\n      else if(x >= 10 & x < 20) return(\"M\")\n      else if(x >= 20) return(\"H\")\n      else stop(\"No solution!\")\n    } else if (type == \"num\") {\n      if (x < 10) return(1)\n      else if(x >= 10 & x < 20) return(2)\n      else if(x >= 20) return(3)\n      else stop(\"No solution!\")\n    } else stop(\"Input \\\"x\\\" has to be either of type \\\"char\\\" or \\\"num\\\"!\")\n  }\n}\n\nassign_var <- function(x, var_type, ...) {\n  var_type = tolower(var_type)\n  if(var_type == \"hastighed\") return(assign_ws(x, ...))\n  else if(var_type == \"retning\") return(assign_wd(x, ...))\n  else return(0)\n}\n\n## ------------------------------------------------------------------------- ##\nwddiff <- function(x) {\n  stopifnot(is.numeric(x) & length(x) > 1)\n  a <- x[1] - x[-1]\n  b <- x[1] - (x[-1] + 360)\n  r <- matrix(c(a, b), ncol = 2, byrow = F)\n  apply(r, 1, function(s) s[which.min(abs(s))])\n}\n\nwdmean <- function(x) {\n  z <- round(mean(c(x[1], x[1] - wddiff(x)/2)), 1)\n  return(if(z <= 0) z + 360 else if(z > 360) z - 360 else z)\n}\n\n## ------------------------------------------------------------------------- ##\ndiff_wd <- function(x, y) {\n  if(is.na(x) | is.na(y)) {\n    return(NA)\n  } else {\n    a <- x - y\n    b <- x - (y + 360)\n    r <- c(a, b)\n    return(r[which.min(abs(r))])  \n  }\n}\n\n## ------------------------------------------------------------------------- ##\nmycor <- function(wp) {\n  cor0 <- wp %>% summarize(ws_num = 0, wd_num = 0, p = 1, cor = cor(Husahagi, Suduroy, use = \"pairwise.complete.obs\"))\n  cor1d <- wp %>% group_by(wd_num) %>% summarize(n = n(), cor = cor(Husahagi, Suduroy, use = \"pairwise.complete.obs\")) %>% \n    mutate(N = sum(n), p = n/N, ws_num = 0) %>% select(ws_num, wd_num, p, cor)\n  cor1s <- wp %>% group_by(ws_num) %>% summarize(n = n(), cor = cor(Husahagi, Suduroy, use = \"pairwise.complete.obs\")) %>%\n    mutate(N = sum(n), p = n/N, wd_num = 0) %>% select(ws_num, wd_num, p, cor)\n  cor2 <- wp %>% group_by(ws_num, wd_num) %>% summarize(n = n(), cor = cor(Husahagi, Suduroy, use = \"pairwise.complete.obs\")) %>%\n    mutate(N = sum(n), p = n/N) %>% select(ws_num, wd_num, p, cor)\n  corall <- bind_rows(cor0, cor1d, cor1s, cor2)\n  corall$ws_niv <- corall$wd_niv <- NA\n  for(i in 1:nrow(corall)) {\n    corall$ws_niv[i] <- hlabel(corall$ws_num[i])\n    corall$wd_niv[i] <- rlabel(corall$wd_num[i])\n  }\n  return(corall)\n}\n\nmyfejl <- function(wp) {\n  e0 <- wp %>% summarize(ws_num = 0, wd_num = 0, mae = mae(e), mae_p = mae(e_per)) %>% select(ws_num, wd_num, mae, mae_p)\n  e1s <- wp %>% group_by(ws_num) %>% summarize(wd_num = 0, mae = mae(e), mae_p = mae(e_per)) %>% select(ws_num, wd_num, mae, mae_p)\n  e1d <- wp %>% group_by(wd_num) %>% summarize(ws_num = 0, mae = mae(e), mae_p = mae(e_per)) %>% select(ws_num, wd_num, mae, mae_p)\n  e2 <- wp %>% group_by(ws_num, wd_num) %>% summarize(mae = mae(e), mae_p = mae(e_per)) %>% select(ws_num, wd_num, mae, mae_p)\n  eall <- bind_rows(e0, e1d, e1s, e2)\n}\n\n## ------------------------------------------------------------------------- ##\nrlabel <- function(x) {\n  if (x == 1) return(\"N\")\n  else if (x == 2) return(\"Ø\")\n  else if (x == 3) return(\"S\")\n  else if (x == 4) return(\"V\")\n  else return(\"Alle\")\n}\n\nhlabel <- function(x) {\n  if (x == 1) return(\"L\")\n  else if (x == 2) return(\"M\")\n  else if (x == 3) return(\"H\")\n  else return(\"Alle\")\n}\n\n## ------------------------------------------------------------------------- ##\n# Beregner mean absolute error mellem x og y (hvis kun x er defineret som input anses x for at være fejlen)\nmae <- function(x, y = NULL) {\n  stopifnot(is.vector(x))\n  if (!is.null(y)) {\n    stopifnot(is.vector(y) & length(y) == length(x))\n    x <- x - y\n  }\n  sum(abs(x))/length(x)\n}\n\n## ------------------------------------------------------------------------- ##\n# Funktioner til effektkurveberegning\nssquares <- function(x, y = NULL, na.action = na.rm) {\n  stopifnot(is.numeric(x))\n  if(!is.null(y)) {\n    stopifnot(is.numeric(y) & length(y) == length(x))\n    x <- x - y\n  }\n  x <- x[!is.na(x)]\n  x %*% x\n}\n\noptfun <- function(p, y, fun, ...) {\n  yhat <- myfun(p, ...)\n  ssquares(x = y, y = yhat)\n}\n\nmyfun <- function(p, x, p0 = T) {\n  y <- if (p0) p[1] + p[2] * x + p[3] * x^2 + p[4] * x^3 else\n    p[1] * x + p[2] * x^2 + p[3] * x^3\n  return(apply(cbind(y, 0), 1, max, na.rm = T))\n}\n\n## --\nmyout_ret <- function(x, r, mypar, p0 = T) {\n  myfun(p = mypar[r, ], x = x, p0 = p0)\n}\n\n## ------------------------------------------------------------------------- ##\n## ------------------------------------------------------------------------- ##\n",
    "created" : 1477304710089.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "531130847",
    "id" : "3C90D9F1",
    "lastKnownWriteTime" : 1477474156,
    "last_content_update" : 1477474156065,
    "path" : "G:/ELT/R/SEV/Suduroy/libs/fncs.R",
    "project_path" : "libs/fncs.R",
    "properties" : {
        "source_window_id" : "ws48eigpvy7x2",
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}